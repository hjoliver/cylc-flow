#!/usr/bin/env python

# THIS FILE IS PART OF THE CYLC SUITE ENGINE.
# Copyright (C) 2008-2018 NIWA
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""cylc [info] cat-log|log [OPTIONS] ARGS

Cat (print contents of) to stdout, view in editor, or tail-follow suite or task
job logs, or print their locations. Works for local and remote jobs, and with
batch-system-specific commands to cat or tail the stdout and stderr of live
jobs (set in Cylc global config).

For task job logs, the correct cycle point format for the suite must be used.
To list the local job log directory of a remote task, choose 'list-dir' mode
and a local-only file such as job-activity.log: -m l -f a.

Note the --host/user options are not needed to view remote job logs. They are
the general command reinvocation options for sites using ssh-based task
messaging."""

import sys
from cylc.remote import remrun, remote_cylc_cmd
if remrun():
    sys.exit(0)

import os
import re
import shlex
import signal
import traceback
from glob import glob
from time import sleep
from pipes import quote
from tempfile import mkstemp
from subprocess import Popen, PIPE

from cylc.option_parsers import CylcOptionParser as COP
from cylc.rundb import CylcSuiteDAO
from cylc.hostuserutil import is_remote
from cylc.cfgspec.glbl_cfg import glbl_cfg
from cylc.task_id import TaskID
from cylc.suite_logging import SUITE_LOG_OPTS
from cylc.task_job_logs import JOB_LOG_OPTS, OPT_JOB_OUT, OPT_JOB_ERR, NN
from parsec.fileparse import read_and_proc


MODES = {
    'p': 'print',
    'l': 'list-dir',
    'd': 'print-dir',
    'c': 'cat',
    't': 'tail',
    'e': 'edit'
}


# TODO - check behaviour for remote and local file not found.

def get_user_and_host(user_at_host):
    if user_at_host is None:
        user, host = None, None
    elif "@" in user_at_host:
        user, host = user_at_host.split("@", 1)
    else:
        user, host = (None, user_at_host)
    return (user, host)


def get_user_at_host(user, host):
    user_at_host = None
    if is_remote(host, user):
        if host and user:
            user_at_host = user + "@" + host
        elif host:
            user_at_host = host
        elif user:
            user_at_host = user + "@localhost"
    return user_at_host


def elucidate(logpath, mode, tailer_tmpl, command0=None, remote=False):
    """Command0 is batch system out or err viewer or tailer."""
    if mode == 'print':
        # Print location even if the suite does not exist yet.
        print logpath
        return 0
    elif not os.path.exists(logpath):
        print >> sys.stderr, 'ERROR: file not found: %s' % logpath
        return 1
    elif mode == 'print-dir':
        print os.path.dirname(logpath)
        return 0
    elif mode == 'list-dir':
        for entry in os.listdir(os.path.dirname(logpath)):
            print entry
        return 0
    elif not remote and mode == 'edit':
        content = ''
        with open(logpath, 'r') as log:
            content = log.read()
        return content
    elif mode == 'cat' or (remote and mode == 'edit'):
        if command0 is not None:
            cmd = command0
        else:
            cmd = 'cat %s' % logpath
        proc = Popen(shlex.split(cmd), stdin=open(os.devnull))
        proc.wait()
        return 0
    elif mode == 'tail':
        if command0 is not None:
            cmd = command0
        else:
            cmd = tailer_tmpl % {"filename": logpath}
        ppid = os.getppid()
        print "!!", cmd
        if remote:
            fn = os.setsid
        else:
            fn = None
        proc = Popen(shlex.split(cmd), stdin=open(os.devnull), preexec_fn=fn)
        while True:
            sleep(0.5)
            if proc.poll() is not None:
                break
            if remote and os.getppid() != ppid:
                os.killpg(proc.pid, signal.SIGTERM)
                break
        proc.wait()
        return 0


def get_option_parser():
    """Set up the CLI option parser."""
    parser = COP(
        __doc__, argdoc=[("REG", "Suite name"), ("[TASK-ID]", """Task ID""")])

    parser.add_option(
        "-f", "--file",
        help="Suite log: %s; default l(log)." % (
             ', '.join(['%s(%s)' % (i, j)
                       for i, j in SUITE_LOG_OPTS.items()])) +
             "  Job log: %s; default o(out)." % (
             ', '.join(['%s(%s)' % (i, j)
                       for i, j in JOB_LOG_OPTS.items()])) +
             "  Or <filename> for custom (and standard) job logs.",
        metavar="LOG", action="store", default=None, dest="filename")

    parser.add_option(
        "-m", "--mode",
        help="Mode: %s. Default c(cat)." % (
            ', '.join(['%s(%s)' % (i, j) for i, j in MODES.items()])),
        action="store", choices=MODES.keys(), default='c', dest="mode")

    parser.add_option(
        "-r", "--rotation",
        help="Suite log integer rotation number. 0 for current, 1 for "
        "next oldest, etc.",
        metavar="INT", action="store", dest="rotation_num")

    parser.add_option(
        "-s", "--submit-number", "-t", "--try-number",
        help="Job submit number (default=%s, i.e. latest)." % NN,
        metavar="INT", action="store", dest="submit_num", default=NN)

    parser.add_option(
        "-g", "--geditor",
        help="edit mode: use your configured GUI editor.",
        action="store_true", default=False, dest="geditor")

    parser.add_option(
        "--remote-mode",
        help="(for internal use: continue processing on job host)",
        action="store_true", default=False, dest="remote_mode")

    return parser


def get_task_job_log_path(
        options, suite_name, point, task, submit_num, user_at_host):
    """Return file name of a task job log, given the options."""
    if user_at_host and "@" in user_at_host:
        user, host = user_at_host.split("@", 1)
    else:
        user, host = (None, user_at_host)
    try:
        basename = JOB_LOG_OPTS[options.filename or 'o']
    except KeyError:
        basename = options.filename
    if submit_num != NN:
        submit_num = "%02d" % int(submit_num)
    if os.path.isabs(basename):
        return basename
    else:
        return os.path.normpath(os.path.join(
            glbl_cfg().get_derived_host_item(
                suite_name, "suite job log directory", host, user),
            point, task, submit_num, basename))


def get_task_job_attrs(options, suite_name, point, task, submit_num):
    """Return (user@host, command0) of a task job log.

    user@host is set if task job is run remotely and for relevant log files.
    command0 is set if task job is running on a batch system that requires a
    special command to view stdout/stderr files.

    """
    if options.filename in ['d', 'a']:
        return (None, None)
    suite_dao = CylcSuiteDAO(
        os.path.join(
            glbl_cfg().get_derived_host_item(suite_name,
            "suite run directory"),
            "log", CylcSuiteDAO.DB_FILE_BASE_NAME),
        is_public=True)
    task_job_data = suite_dao.select_task_job(None, point, task, submit_num)
    suite_dao.close()
    if task_job_data is None:
        return (None, None)
    if "@" in task_job_data["user_at_host"]:
        user, host = str(task_job_data["user_at_host"]).split("@", 1)
    else:
        user, host = (None, str(task_job_data["user_at_host"]))
    user_at_host = get_user_at_host(user, host)
    # Use special batch system commands to view job out or err (e.g. "qcat
    # [-f]") if the job is still running.
    if (options.mode in ['l', 'p'] or options.filename not in ['e', 'o'] or
            not task_job_data["batch_sys_name"] or
            not task_job_data["batch_sys_job_id"] or
            not task_job_data["time_run"] or task_job_data["time_run_exit"]):
        return (user_at_host, None)
    try:
        user, host = get_user_and_host(user_at_host)
        if options.filename == OPT_JOB_OUT:
            if options.mode == 'c':
                key = "out viewer"
            elif options.mode == 't':
                key = "out tailer"
        elif options.filename == OPT_JOB_ERR:
            if options.mode == 'c':
                key = "err viewer"
            elif options.mode == 't':
                key = "err tailer"
        conf = glbl_cfg().get_host_item("batch systems", host, user)
        command0_tmpl = conf[str(task_job_data["batch_sys_name"])][key]
    except (KeyError, TypeError) as exc:
        return (user_at_host, None)
    else:
        if command0_tmpl:
            return (user_at_host, command0_tmpl % {
                "job_id": str(task_job_data["batch_sys_job_id"])})
        else:
            return (user_at_host, None)


def tmpfile_edit(filestr, logpath, geditor=False):
    if geditor:
        editor = GLOBAL_CFG.get(['editors', 'gui'])
    else:
        editor = GLOBAL_CFG.get(['editors', 'terminal'])
    viewfile = mkstemp(dir=GLOBAL_CFG.get_tmpdir())[1]
    with open(viewfile, 'w') as vf:
        vf.write(filestr)
    os.chmod(viewfile, 0400)
    modtime1 = os.stat(viewfile).st_mtime

    cmd = shlex.split(editor)
    cmd.append(viewfile)
    proc = Popen(cmd, stderr=PIPE)
    err = proc.communicate()[1]
    ret_code = proc.wait()
    if ret_code == 0:
        if os.stat(viewfile).st_mtime > modtime1:
            sys.stderr.write(
                'WARNING: you edited a TEMPORARY COPY of %s' % (
                    os.path.basename(logpath)))
    if ret_code and err:
        sys.stderr.write(err)


def main():
    """Implement cylc cat-log CLI.

    Determine log path, user@host, command0, and action (print, dir-list, cat,
    edit, or tail) then:
      a) if log path is local, perform action on log path, or
      b) if log path is remote, reinvoke on remote account via ssh as a) - so
    that remote interaction is always behind a "cylc" command for ssh
    whitelisting in secure environments.

    """

    # TODO - TEST ERROR HANDLING VIA CLI and GUI

    parser = get_option_parser()
    options, args = parser.parse_args()

    # TODO choices=SUITE_LOG_OPTS.keys() + JOB_LOG_OPTS.keys()

    if options.remote_mode:
        # Invoked on job hosts for job logs only, as a wrapper to elucidate().
        xargs = args[0].split(',')
        logpath = xargs[0]
        mode = xargs[1]
        # (This must be retrieve from global config on suite host):
        tail_tmpl = xargs[2]
        try:
            command0 = xargs[3]
        except IndexError:
            command0 = None
        res = elucidate(logpath, mode, tail_tmpl, command0, remote=True)
        if res == 1:
            sys.exit(res)
        return

    suite_name = args[0]
    mode = MODES[options.mode]

    if len(args) == 1:
        # Cat suite logs, local only.
        try:
            basename = SUITE_LOG_OPTS[options.filename or 'l']
        except KeyError:
            basename = options.filename
        logdir = GLOBAL_CFG.get_derived_host_item(
            suite_name, "suite log directory")
        logpath = os.path.join(logdir, basename)
        if options.rotation_num:
            logs = glob('%s.*' % logpath)
            logs.sort(key=os.path.getmtime, reverse=True)
            try:
                logpath = logs[int(options.rotation_num)]
            except IndexError:
                sys.exit("ERROR: max rotation %d" % (len(logs) - 1))
        else:
            logpath = os.path.join(logdir, basename)
        tail_tmpl = str(GLOBAL_CFG.get_host_item("tail command template"))
        out = elucidate(logpath, MODES[options.mode], tail_tmpl)
        if out == 1:
            sys.exit(1)
        if mode == 'edit':
            tempfile_edit(out)
        return

    if len(args) == 2:
        # Cat task job logs, may be on suite or job host.
        if options.rotation_num is not None:
            sys.exit("ERROR: rotation is a suite (not job) log property")
        task_id = args[1]
        try:
            task, point = TaskID.split(task_id)
        except ValueError:
            parser.error("Illegal task ID: %s" % task_id)
        if options.submit_num != NN:
            try:
                submit_num = int(options.submit_num)
            except ValueError:
                parser.error("Illegal submit number: %s" % options.submit_num)
        user_at_host, command0 = get_task_job_attrs(
            options, suite_name, point, task, options.submit_num)
        logpath = get_task_job_log_path(
            options, suite_name, point, task, options.submit_num, user_at_host)
        out = None
        if user_at_host:
            # Reinvoke as a wrapper on the remote account.
            user, host = get_user_and_host(user_at_host)
            tail_tmpl = str(glbl_cfg().get_host_item(
                "tail command template", host, user))
            cmd = 'cat-log --remote-mode %s,%s,%s' % (
                logpath, mode, quote(tail_tmpl % {"filename": logpath}))
            if command0:
                cmd += ',%s' % quote(command0)
            capture = (mode == 'edit')
            try:
                out = remote_cylc_cmd(cmd, user, host, capture)
            except KeyboardInterrupt:
                # Ctrl-C while tailing.
                pass
        else:
            tail_tmpl = str(glbl_cfg().get_host_item("tail command template"))
            out = elucidate(logpath, mode, tail_tmpl, command0)
            if out == 1:
                sys.exit(1)
        if mode == 'edit':
            tmpfile_edit(out, logpath, options.geditor)


if __name__ == "__main__":
    main()
